# MySQL 支持的事务隔离级别详解

MySQL 支持多种事务隔离级别，用以控制并发事务之间的可见性和交互方式，确保数据一致性。不同隔离级别在数据一致性和并发性能之间做出不同的权衡。下面详细说明 MySQL 支持的主要事务隔离级别及其特点。

---

## 1. 事务隔离级别概述

事务隔离级别定义了多个并发事务之间的交互规则，主要目标是防止数据不一致问题，如脏读、不可重复读和幻读。MySQL 中常用的四种隔离级别（从最低到最高）分别是：
- 读未提交（Read Uncommitted）
- 读已提交（Read Committed）
- 可重复读（Repeatable Read）
- 串行化（Serializable）

每个隔离级别都提供了不同的并发控制力度和性能表现。

---

## 2. 各隔离级别详解

### 2.1 读未提交（Read Uncommitted）

- **定义**：  
  允许事务读取其他事务尚未提交的数据。
- **特点**：
    - 可能发生 **脏读**：即一个事务读取到其他未提交事务的数据，如果后者回滚，则读取到的数据不一致。
    - 并发性最高，但数据一致性最低。
- **应用场景**：  
  适用于数据一致性要求不高、对性能要求极高的场景，但实际应用中较少使用。

---

### 2.2 读已提交（Read Committed）

- **定义**：  
  一个事务只能读取到其他事务已提交的数据。
- **特点**：
    - 避免了脏读问题。
    - 可能出现 **不可重复读**：同一事务中两次读取同一数据时，由于其他事务的提交，结果可能不同。
    - 在多数商业数据库中为默认隔离级别，但 MySQL InnoDB 默认隔离级别是可重复读。
- **应用场景**：  
  适合对数据一致性要求中等，但需要较高并发性能的应用。

---

### 2.3 可重复读（Repeatable Read）

- **定义**：  
  保证在同一事务内多次读取相同数据结果一致，即使其他事务已提交数据更新。
- **特点**：
    - 解决了不可重复读问题。
    - MySQL InnoDB 的默认隔离级别。
    - 可能发生 **幻读**：在一些复杂查询中，同一事务内后续查询可能会出现新增的数据行（不过 InnoDB 通过 Next-Key Lock 实现了一定程度的幻读防护）。
- **应用场景**：  
  常用于对数据一致性要求较高的事务操作中，如金融和订单处理系统。

---

### 2.4 串行化（Serializable）

- **定义**：  
  最高级别的隔离级别，通过强制事务串行执行来避免并发问题。
- **特点**：
    - 完全避免脏读、不可重复读和幻读。
    - 通过在每个查询上加锁实现，导致并发性能显著降低。
- **应用场景**：  
  适用于对数据一致性要求极高，且并发量较低的场景，如某些关键数据操作。

---

## 3. 如何设置隔离级别

### 3.1 查看当前隔离级别
```sql
-- 查看当前会话的隔离级别
SELECT @@session.tx_isolation;

-- 或者在 MySQL 8.0 及更高版本使用
SELECT @@session.transaction_isolation;
```

### 3.2 设置隔离级别
- **针对当前会话**：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
  ```
- **针对全局设置**（需管理员权限，影响新连接）：
  ```sql
  SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  ```

---

## 4. 总结

MySQL 支持四种主要事务隔离级别，各自具有不同的并发性能和数据一致性保障：
- **读未提交**：最高并发，但数据一致性最差，可能出现脏读。
- **读已提交**：避免脏读，但可能出现不可重复读，适用于大多数中等一致性要求的场景。
- **可重复读**：MySQL InnoDB 默认隔离级别，保证同一事务内多次读取一致，但可能出现幻读（通常通过锁机制进行防护）。
- **串行化**：最严格的隔离级别，确保最高数据一致性，但并发性能最低。

根据具体业务需求和并发要求，选择合适的隔离级别可以在数据一致性和性能之间取得平衡。